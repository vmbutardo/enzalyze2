{
    "contents" : "##' Returns statistics for linear regressions (e.g. slope, intercept, error, etc)\n##' \n##' @param d Data frame containing at least two numeric columns\n##' @param xvar Numeric column to be used as the independant variable for the regression\n##' @param yvar Numeric column to be used as the dependant variable for the regression\n##' @details include some details here\n##' @return Returns a one-row data frame containing (at present): slope, intercept, slope standard error, intercept standard error, p value, r-squared, and number of points.\n##' @export\n##' require(ggplot2)\n##' lm_stats(mpg, xvar=\"cty\", yvar=\"hwy\")\n\n\nlm_stats <- function(d, xvar, yvar) {\n  # Function to safely return the slope, intercept, slope.se, int.se, rsq, and pvalue of a linear model\n  \n  \n  # Check that the relevant columns are in your data frame\n  if(!(xvar %in% names(d))) {\n    stop(paste(\"The data frame has no column named\", xvar))\n  }\n  if(!(yvar %in% names(d))) {\n    stop(paste(\"The data frame has no column named\", yvar))\n  }\n  \n  \n  \n  m <- lm(d[ , yvar] ~ d[ , xvar]) # Should wrap this in a tryCatch too!\n  # Alsom improve error message if xvar or yvar arent in d\n  sum_m <- summary(m)\n  \n  # Function to safely get the slope\n  get_slope <- function(m) {\n    slope <- tryCatch(\n      slope <- sum_m$coefficients[2,1],\n      error=function(cond) return(NA),\n      warning=function(cond) return(slope),\n      finally = {}\n    )\n    return(slope)\n  }\n  \n  # Function to safely get the intercept\n  get_int <- function(m) {\n    int <- tryCatch(\n      int <- sum_m$coefficients[1,1],\n      error=function(cond) return(NA),\n      warning=function(cond) return(int),\n      finally = {}\n    )\n    return(int)\n  }\n  \n  # Function to safely get the standard error of the intercept\n  get_int.se <- function(m) {\n    int.se <- tryCatch(\n      int.se <- sum_m$coefficients[1,2],\n      error=function(cond) return(NA),\n      warning=function(cond) return(int.se),\n      finally = {}\n    )\n    return(int.se)\n  }\n  \n  # Function to safely get the standard error of the slope\n  get_slope.se <- function(m) {\n    slope.se <- tryCatch(\n      slope.se <- sum_m$coefficients[2,2],\n      error=function(cond) return(NA),\n      warning=function(cond) return(slope.se),\n      finally = {}\n    )\n    return(slope.se)\n  }\n  \n  # Function to safely get the p value\n  get_p_val <- function(m) {\n    pval <- tryCatch(\n      pval <- sum_m$coefficients[2,4], #that's the p value for the slope - NOTE I WANT THE P VALUE FOR THE WHOLE MODEL!!!!\n      error=function(cond) {\n        return(NA)\n      },\n      warning=function(cond) {\n        return(pval)\n      },\n      finally={}\n    )    \n    return(pval)\n  }\n  \n  # Function to safely get the r-squared value\n  get_rsq <- function(m) {\n    rsq <- tryCatch(\n      rsq <- sum_m$r.squared,\n      error=function(cond) return(NA),\n      warning=function(cond) return(rsq),\n      finally = {}\n    )\n    return(rsq)\n  }\n  \n  n <- nrow(d[!is.na(d[ , xvar]) & !is.na(d[ , yvar]), ]) # I can't really think of how this would throw errors\n  \n  # Return the parameters in a 1-row data frame (the most convenient format for plyr functions)\n  data.frame(slope = get_slope(m), \n             int = get_int(m), \n             slope.se=get_slope.se(m), \n             int.se=get_int.se(m), \n             pval=get_p_val(m),\n             rsq = get_rsq(m),\n             n=n)\n}\n\n\n",
    "created" : 1402612452720.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2810326607",
    "id" : "E949DA33",
    "lastKnownWriteTime" : 1402612876,
    "path" : "~/Dropbox/Drew/enzalyze2/R/lm_stats.R",
    "project_path" : "R/lm_stats.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}